name: Build and Test

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  # Database configuration for CI
  POSTGRES_SERVER: localhost
  POSTGRES_PORT: 5432
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  POSTGRES_DB: vibetravel_test

  # FastAPI Settings for CI
  PROJECT_NAME: VibeTravels
  SECRET_KEY: test-secret-key-for-ci
  ENVIRONMENT: dev
  API_V1_STR: /api/v1
  BACKEND_CORS_ORIGINS: '["http://localhost:3000", "http://localhost:8080"]'

  # First Admin User for tests
  FIRST_SUPERUSER: admin@test.com
  FIRST_SUPERUSER_PASSWORD: testpassword

  # AI generation settings (mock for CI)
  USE_MOCK_AI: 1
  OPENROUTER_API_KEY: mock-key
  OPENROUTER_MODEL: mock-model

jobs:
  backend:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: vibetravel_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        load: true
        tags: backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Create .env file
      run: |
        cat > .env << EOF
        PROJECT_NAME=${PROJECT_NAME}
        SECRET_KEY=${SECRET_KEY}
        ENVIRONMENT=${ENVIRONMENT}
        API_V1_STR=${API_V1_STR}
        BACKEND_CORS_ORIGINS=${BACKEND_CORS_ORIGINS}
        POSTGRES_SERVER=${POSTGRES_SERVER}
        POSTGRES_PORT=${POSTGRES_PORT}
        POSTGRES_USER=${POSTGRES_USER}
        POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        POSTGRES_DB=${POSTGRES_DB}
        FIRST_SUPERUSER=${FIRST_SUPERUSER}
        FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}
        USE_MOCK_AI=${USE_MOCK_AI}
        OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
        OPENROUTER_MODEL=${OPENROUTER_MODEL}
        EOF

    - name: Wait for PostgreSQL to be ready
      run: |
        until pg_isready -h localhost -p 5432 -U postgres; do
          echo "Waiting for postgres..."
          sleep 2
        done

    - name: Run backend linting
      run: |
        docker run --rm \
          -v ${{ github.workspace }}/backend:/app \
          -w /app \
          backend:latest \
          ./scripts/lint.sh

    - name: Run database pre-start checks
      run: |
        docker run --rm \
          --env-file .env \
          --network host \
          -v ${{ github.workspace }}/backend:/app \
          -w /app \
          backend:latest \
          python tests_pre_start.py

    - name: Run backend tests
      run: |
        docker run --rm \
          --env-file .env \
          --network host \
          -v ${{ github.workspace }}/backend:/app \
          -w /app \
          backend:latest \
          sh -c "coverage run --source=src -m pytest -vv && coverage report && coverage xml && coverage html"

    - name: Upload backend coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: backend-coverage
        path: backend/htmlcov/
        retention-days: 7

    - name: Upload backend coverage XML
      uses: actions/upload-artifact@v4
      with:
        name: backend-coverage-xml
        path: backend/coverage.xml
        retention-days: 7

  frontend:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        load: true
        tags: frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VITE_BACKEND_URL=http://localhost:8000

    - name: Run frontend linting
      run: |
        docker run --rm \
          -v ${{ github.workspace }}/frontend:/app \
          -v /app/node_modules \
          -w /app \
          frontend:latest \
          sh -c "npm run lint"

    - name: Run frontend type checking
      run: |
        docker run --rm \
          -v ${{ github.workspace }}/frontend:/app \
          -v /app/node_modules \
          -w /app \
          frontend:latest \
          sh -c "npm run type-check"

    - name: Run frontend tests with coverage
      run: |
        # Run tests without mounting coverage directory
        docker run --name frontend-test \
          -v ${{ github.workspace }}/frontend:/app \
          -v /app/node_modules \
          -w /app \
          frontend:latest \
          sh -c "npm run test:coverage"

        # Copy coverage from container to host
        mkdir -p ${{ github.workspace }}/frontend-coverage
        docker cp frontend-test:/app/coverage/. ${{ github.workspace }}/frontend-coverage/
        docker rm frontend-test

    - name: Upload frontend coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: frontend-coverage
        path: frontend-coverage/
        retention-days: 7

  generate-badges:
    runs-on: ubuntu-latest
    needs: [backend, frontend]
    if: always() && github.ref == 'refs/heads/master'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download backend coverage XML
      uses: actions/download-artifact@v4
      with:
        name: backend-coverage-xml
        path: ./backend-coverage-xml/
      continue-on-error: true

    - name: Download frontend coverage
      uses: actions/download-artifact@v4
      with:
        name: frontend-coverage
        path: ./frontend-coverage/
      continue-on-error: true

    - name: Generate Backend Coverage Badge
      uses: 5monkeys/cobertura-action@master
      with:
        path: backend-coverage-xml/coverage.xml
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        minimum_coverage: 70
        fail_below_threshold: false
        show_line: true
        show_branch: true
        show_class_names: true
        only_changed_files: false
        report_name: Backend Coverage
      continue-on-error: true

    - name: Create Frontend Coverage Badge
      run: |
        if [ -f "./frontend-coverage/coverage-final.json" ]; then
          # Extract coverage percentage from JSON
          COVERAGE=$(node -pe "
            const fs = require('fs');
            const coverage = JSON.parse(fs.readFileSync('./frontend-coverage/coverage-final.json', 'utf8'));
            const totals = coverage.total;
            Math.round((totals.statements.covered / totals.statements.total) * 100);
          ")

          # Determine color based on coverage
          if [ $COVERAGE -ge 80 ]; then
            COLOR="brightgreen"
          elif [ $COVERAGE -ge 70 ]; then
            COLOR="yellow"
          else
            COLOR="red"
          fi

          echo "Frontend Coverage: ${COVERAGE}% (${COLOR})"

          # Create badge URL
          BADGE_URL="https://img.shields.io/badge/Frontend%20Coverage-${COVERAGE}%25-${COLOR}"
          echo "FRONTEND_COVERAGE_BADGE=${BADGE_URL}" >> $GITHUB_ENV
        else
          echo "Frontend coverage file not found"
          echo "FRONTEND_COVERAGE_BADGE=https://img.shields.io/badge/Frontend%20Coverage-unknown-lightgrey" >> $GITHUB_ENV
        fi

    - name: Update README with coverage badges
      run: |
        if [ -n "$FRONTEND_COVERAGE_BADGE" ]; then
          echo "Frontend badge URL: $FRONTEND_COVERAGE_BADGE"
          # Here you could automatically update README or create a comment
        fi

  status-comment:
    runs-on: ubuntu-latest
    needs: [backend, frontend, generate-badges]
    if: always() && github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download backend coverage
      uses: actions/download-artifact@v4
      with:
        name: backend-coverage
        path: ./backend-coverage/
      continue-on-error: true

    - name: Download frontend coverage
      uses: actions/download-artifact@v4
      with:
        name: frontend-coverage
        path: ./frontend-coverage/
      continue-on-error: true

    - name: Create status comment
      uses: actions/github-script@v7
      with:
        script: |
          const backendStatus = '${{ needs.backend.result }}';
          const frontendStatus = '${{ needs.frontend.result }}';
          const badgeStatus = '${{ needs.generate-badges.result }}';

          const statusEmoji = {
            'success': 'âœ…',
            'failure': 'âŒ',
            'cancelled': 'â¹ï¸',
            'skipped': 'â­ï¸'
          };

          const overallStatus = backendStatus === 'success' && frontendStatus === 'success' ? 'success' : 'failure';

          // Try to extract coverage info
          let coverageInfo = '';
          try {
            const fs = require('fs');

            // Frontend coverage
            if (fs.existsSync('./frontend-coverage/coverage-final.json')) {
              const frontendCoverage = JSON.parse(fs.readFileSync('./frontend-coverage/coverage-final.json', 'utf8'));
              const frontendPercent = Math.round((frontendCoverage.total.statements.covered / frontendCoverage.total.statements.total) * 100);
              coverageInfo += `\n- **Frontend Coverage:** ${frontendPercent}%`;
            }
          } catch (e) {
            console.log('Could not extract coverage info:', e.message);
          }

          const comment = `## ðŸš€ Build Status Report

          **Overall Status:** ${statusEmoji[overallStatus]} ${overallStatus.toUpperCase()}

          ### Component Results:
          - **Backend:** ${statusEmoji[backendStatus]} ${backendStatus.toUpperCase()}
          - **Frontend:** ${statusEmoji[frontendStatus]} ${frontendStatus.toUpperCase()}
          ${badgeStatus !== 'skipped' ? `- **Coverage Badges:** ${statusEmoji[badgeStatus]} ${badgeStatus.toUpperCase()}` : ''}
          ${coverageInfo}

          ### Details:
          - **Commit:** ${context.sha.substring(0, 7)}
          - **Workflow:** [${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})
          - **Branch:** ${context.ref.replace('refs/heads/', '')}

          ${overallStatus === 'success' ?
            'ðŸŽ‰ All checks passed! Ready for review.' :
            'ðŸ” Some checks failed. Please review the details above.'}
          `;

          // Find existing comment to update or create new one
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingComment = comments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('ðŸš€ Build Status Report')
          );

          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }
